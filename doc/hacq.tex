\documentclass[11pt]{article}
\usepackage[scale=0.8]{geometry}
\usepackage{times}
% Because the sans-serif font chosen by times package looks too large,
% we use the sans-serif font used by txfonts.
\renewcommand{\sfdefault}{txss}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{url}

\lstset{language={},columns=flexible,basicstyle=\sffamily,escapechar=\#}

\DeclarePairedDelimiter{\ket}{\lvert}{\rangle}

\title{Hacq: A circuit description language for quantum circuits}
\author{Tsuyoshi Ito \\
  NEC Laboratories America, Inc.}
\date{}

\bibliographystyle{TIalpha}

\newcommand{\var}[1]{\mathit{#1}}

\begin{document}
\maketitle

\section{Introduction}

Hacq%
\footnote{``Hacq'' is pronounced as /h\ae k/ just like the English word ``hack.''
  It stands for ``\textbf{Ha}skell \textbf{c}ombinators for \textbf{q}uantum circuits.''}
is a circuit description language for quantum circuits,
which was originally developed
for the research project ``Tools to Optimize Resources in Quantum Engineering (TORQUE)''
in the Quantum Computer Science (QCS) Program
of the Intelligence Advanced Research Projects Activity (IARPA).
Hacq allows a programmer to write structured quantum circuits concisely.
Quantum circuits written in Hacq can be easily converted to a netlist in the standard gate set
in the QC format used by QCViewer~\cite{QCViewer} if they are small enough.
Moreover, reflecting the need in the IARPA QCS Program,
even for huge quantum circuits whose netlist would be too large to store or process,
Hacq produces the metric such as the number of gates, the width, and the depth
of the circuits converted to the standard gate set.

Hacq is developed as an embedded language
in the functional programming language Haskell~\cite{HudHugPeyWad07HOPL},
meaning that Hacq is in fact a library in Haskell
and that a circuit description in Hacq is just a Haskell program which uses this library.
(More precisely, Hacq is written in Haskell with some extensions to the language implemented in GHC~\cite{GHC},
the de facto standard compiler of Haskell.)
Because of this, a programmer can use all language constructs and libraries in Haskell at circuit generation time
when describing quantum circuits.
This is a powerful feature which allows concise description of complex quantum circuits.

Hacq provides a programmer with a set of useful building blocks
to describe various quantum circuits in fairly simple manner.
Some of these building blocks are subcircuits such as the implementation of an adder,
but most of the building blocks provided by Hacq are \emph{combinators},
or functions to construct a circuit from one or more simpler circuits.
An example of combinators in Hacq is \textsf{control},
which takes a quantum circuit for a unitary~$U$ as an argument and returns a circuit for controlled-$U$.
Hacq provides several most common combinators,
and moreover, if the circuit contains a certain pattern which does not fit the combinators predefined in Hacq,
a programmer can also define a new combinator to describe a complex circuit.
This programming paradigm of using combinators to describe complex objects
is well-established in the functional programming community.
In particular, Hacq uses a common variation of the combinator approach
called \emph{monadic combinators}~\cite{Wadler95AFP}.

The distribution of Hacq contains a circuit library
generated by Single Qubit Circuit Toolkit (SQCT)~\cite{KliMasMos-SQCT,KliMasMos13}
to convert circuits which use single-qubit rotation gates with arbitrary angles
to circuits which do not use them.
SQCT is not needed just to use Hacq,
but it is needed to regenerate the circuit library.

This documentation is far from complete.
Users are encouraged to check examples in the ``examples'' folder.

\section{Output}

Hacq processes quantum circuits in two stages: circuit conversion and output generation.

In the first stage, Hacq converts a circuit description
to a quantum circuit in some restricted gate set.
Usually this restricted gate set is the standard gate set:
\footnote{It is also possible to preserve Toffoli gates in the circuit as they are.
  This is useful for visualization of the structure of a small quantum circuit.}
\begin{itemize}
\item One-qubit Pauli gates (X, Y, and Z).
\item The Hadamard gate.
\item The controlled-NOT (or CNOT) gate.
\item The S gate ($\pi/4$-phase shift gates around the Z-axis) and its inverse.
\item The T gate ($\pi/8$-phase shift gates around the Z-axis) and its inverse.
\end{itemize}
In the computational basis, these gates correspond to the following matrices:
\begin{gather*}
  X=\begin{pmatrix}
    0 & 1 \\
    1 & 0
  \end{pmatrix}, \quad
  Y=\begin{pmatrix}
    0 & -i \\
    i & 0
  \end{pmatrix}, \quad
  Z=\begin{pmatrix}
    1 & 0 \\
    0 & -1
  \end{pmatrix}, \quad
  H=\frac{1}{\sqrt2}\begin{pmatrix}
    1 & 1 \\
    1 & -1
  \end{pmatrix}, \quad
  \mathrm{CNOT}=\begin{pmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{pmatrix},
  \\
  S=\begin{pmatrix}
    1 & 0 \\
    0 & i
  \end{pmatrix}, \quad
  S^{-1}=\begin{pmatrix}
    1 & 0 \\
    0 & -i
  \end{pmatrix}, \quad
  T=\begin{pmatrix}
    1 & 0 \\
    0 & e^{i\pi/4}
  \end{pmatrix}, \quad
  T^{-1}=\begin{pmatrix}
    1 & 0 \\
    0 & e^{-i\pi/4}
  \end{pmatrix}.
\end{gather*}

Output generation produces either the netlist in the QC format
or the metric report (or both).
When Hacq is instructed to report the metrics of a circuit, it reports the following:
\begin{itemize}
\item The number of Hadamard gates, the number of CNOT gates,
  the number of S gates and its inverse, the number of T gates and its inverse.
\item The width of the circuit, i.e., the maximum number of qubits which have to be kept simultaneously.
\item The T-depth of the circuit, i.e., the depth of the circuit considering only T gates and their inverses.
\item The T-area of the circuit, i.e., the sum of the lifetimes of each qubit measured in T-depth.
\end{itemize}

\section{Wires and circuits}

In Hacq, a \emph{wire} means a one-qubit register.
A \emph{circuit} in Hacq has the set~$X$ of input wires
and the set~$Y$ of output wires, where~$X\subseteq Y$,
and always represents an isometry matrix
from the Hilbert space corresponding to wires~$X$
to the Hilbert space corresponding to wires~$Y$.
A \emph{unitary circuit} is a circuit with~$X=Y$,
in which case a circuit represents a unitary matrix
on the Hilbert space corresponding to wires~$X$.

A circuit is represented as a value of type \textsf{m a},
where~\textsf{m} is an instance of \textsf{MonadQuantumBase w} for some type~\textsf{w},
and~\textsf{a} is a return type.
The circuit itself is constructed as a side effect,
and the return value does not have to have anything to do with the circuit.
The type of a wire is~\textsf{w}
and it depends on the type of~\textsf{m} via functional dependency.

\textsf{MonadQuantum} is a subclass of \textsf{MonadQuantumBase},
and a programmer is expected to use \textsf{MonadQuantum} or one of its subclasses
to describe a circuit.
We focus on \textsf{MonadQuantum} and its subclasses here.

\section{Basic gates}

Here are some of the predefined circuits which correspond to basic gates:
\begin{itemize}
\item
  \textsf{applyX $\var{w}$}:
  A circuit which applies the NOT gate (aka the Pauli X gate) to wire~$\var{w}$.
  Both input and output consist of the single wire~$\var{w}$.
\item
  \textsf{applyY $\var{w}$}:
  Similar, for the Pauli Y gate.
\item
  \textsf{applyZ $\var{b}$}:
  Similar, for the Pauli Z gate.
  However, the target of the gate is specified as a \emph{bit} instead of a wire.
  See below for the explanation of bits.
\item
  \textsf{applyH $\var{w}$}:
  Similar, for the Hadamard gate.
\item
  \textsf{applyS $\var{b}$ $\var{inv}$}:
  Similar, for the S gate when~$\var{inv}$ is False or its inverse when~$\var{inv}$ is True.
\item
  \textsf{applyT $\var{b}$ $\var{inv}$}:
  Similar, for the T gate when~$\var{inv}$ is False or its inverse when~$\var{inv}$ is True.
\item
  \textsf{newWire}:
  A circuit which allocates a new wire which is in an unknown state.
  It returns the wire.
  The input is the empty set, and the output is the new wire.
\item
  \textsf{ancilla}:
  Similar to \textsf{newWire}, but it allocates a new wire which is initialized to state~$\ket0$.
  (In fact, Hacq treats \textsf{newWire} and \textsf{ancilla} identically,
  and it does not take advantage of the fact
  that the wire returned by \textsf{ancilla} is initialized to~$\ket0$.
  But the distinction might be useful.
  The name \textsf{ancilla} was not a good choice
  because wires allocated by it are not necessarily used as an ancillary space.)
\end{itemize}

A CNOT gate can be described by using function \textsf{applyX}
with the combinator \textsf{control} explained in the next section.

Functions \textsf{applyZ}, \textsf{applyS}, and \textsf{applyT}
take bits instead of wires as arguments.
A \emph{bit} is either a wire, the negation of a wire, constant~$\ket0$, or constant~$\ket1$.
We make distinction between wires and bits
because it does not always make sense to apply a circuit to a constant.
For example, it is not possible to apply NOT to a constant,
because the value of constant cannot be changed.
On the other hand, it is possible to apply CNOT with~$\ket1$ as control,
and it just means NOT.
Technically, it is well-defined to use a constant in place of an input wire of a circuit
if the matrix corresponding to the circuit is block-diagonal with respect to this input wire.
A bit is represented by type \textsf{Bit w}, where~\textsf{w} is the type for a wire.

\section{Basic combinators}

\begin{itemize}
\item
  \textsf{control $\var{b}$ $\var{cir}$} is the circuit
  which applies~$\var{cir}$ controlled by the bit~$\var{b}$ being~$\ket1$.
  If~$\var{b}$ is a wire, it works as a control qubit.
  If~$\var{b}$ is a constant, it is just a generation-time conditional.
  When~$\var{b}$ is a wire, it must not be an output wire of circuit~$\var{cir}$.
\item
  \textsf{parallel $\var{cir}_1$ $\var{cir}_2$}
  is the composition of two circuits~$\var{cir}_1$ and~$\var{cir}_2$,
  with an additional guarantee by the programmer
  that no wire is used as an output wire of both~$\var{cir}_1$ and~$\var{cir}_2$.
  Hacq chooses to use parallel composition when it knows parallel composition
  is possible from this guarantee.
  That is, it produces the parallel composition
  if there are no control wires,
  and it produces the sequential composition if there are any control wires.
  The return value is the pair of the return values of~$\var{cir}_1$ and~$\var{cir}_2$.
  In what follows, composition of two or more circuits with this assumption
  is called \emph{optionally-parallel composition}.
\item
  \textsf{parallel\_ $\var{cir}_1$ $\var{cir}_2$} is similar
  except that it discards the return values of~$\var{cir}_1$ and~$\var{cir}_2$.
\item
  \textsf{with\_ $\var{prepare}$ $\var{body}$} is the sequential composition
  of circuit~$\var{prepare}$, circuit~$\var{body}$,
  and the inverse (more precisely, the adjoint) of circuit~$\var{prepare}$.
  \textsf{with $\var{prepare}$ $\var{body}$} is similar
  with the difference that now~$\var{body}$ is a function
  which takes the return value of~$\var{prepare}$ as an argument
  (just like \textsf{(\textgreater\relax\textgreater=)}).
  The typical use of \textsf{with} is for allocating ancillary space in combination with \textsf{ancilla}:
\begin{lstlisting}[frame=single,caption={Allocation of an ancillary wire using \textsf{ancilla} and \textsf{with}.}]
with ancilla $ \w ->
  -- #\rmfamily $w$ is now a new wire initialized to~$\ket0$.#
  -- #\rmfamily Do something with~$w$ and other wires, and bring~$w$ back to~$\ket0$ in the end.#
\end{lstlisting}
  After this circuit, the wire allocated by \textsf{ancilla} is automatically deallocated.
  In order for this to produce a meaningful quantum circuit,
  all the wires allocated in~$\var{prepare}$ part must be brought back to state~$\ket0$
  when they are deallocated.
\item
  \textsf{$\var{cir}_1$ \textgreater\relax\textgreater\ $\var{cir}_2$}
  means the sequential composition of two circuits.
  \textsf{$\var{cir}_1$ \textgreater\relax\textgreater= $\var{cir}_2$}
  is the same with passing the result from~$\var{cir}_1$.
  These are standard combinators in Haskell.
\item
  \textsf{invert $\var{cir}$} is the inverse of a \emph{unitary} circuit~$\var{cir}$.
  Note that we cannot apply it to a non-unitary circuit,
  in particular not to \textsf{newWire} or \textsf{ancilla}.
\end{itemize}

\section{Replication and iteration}

\begin{itemize}
\item
  \textsf{replicateQ $\var{n}$ $\var{cir}$}
  is the same as \textsf{Seq.replicateA $\var{n}$ $\var{cir}$}.
  That is, it is the sequential composition of~$n$ copies of circuit~$\var{cir}$,
  and returns a \textsf{Seq} of length~$n$,
  whose~$i$th element is the return value of the~$i$th iteration.
  It is provided by Hacq because some of the interpretations allow a huge optimization;
  in these interpretations, the running time of \textsf{replicateQ $\var{n}$ $\var{cir}$}
  is~$O(\log n)$ instead of~$O(n)$.
\item
  \textsf{replicateQ\_ $\var{n}$ $\var{cir}$}
  is the same as \textsf{replicateQ $\var{n}$ $\var{cir}$}
  except that it discards the result.
  This function could be implemented as a function
  of more general type \textsf{Applicative m =\textgreater\ Int -\textgreater\ m a -\textgreater\  m ()}
  (see \textsf{replicateA\_} in src/Util.hs),
  but it is defined as a method of \textsf{MonadQuantumBase} for the same reason as \textsf{replicateQ}.
\item
  \textsf{replicateParallelQ} and \textsf{replicateParallelQ\_}
  are the optionally-parallel versions of \textsf{replicateQ} and \textsf{replicateQ\_}, respectively.
\item
  \textsf{genericReplicateQ\_} and \textsf{genericReplicateParallelQ\_}
  are the ``generic'' versions of \textsf{replicateQ\_} and \textsf{replicateParallelQ\_}
  which take an \textsf{Integral} instead of an \textsf{Int} as parameter~$n$.
\item
  \textsf{mapM}, \textsf{mapM\_}, \textsf{forM}, and \textsf{forM\_}
  in standard Haskell module \textsf{Control.Monad}
  provide the loop construct
  which produces the sequential composition of many similar circuits.
  These functions work only with a list; if you use a \textsf{Seq} instead of a list,
  use the more general versions with the same name in standard Haskell modules
  \textsf{Data.Traversable} and \textsf{Data.Foldable}.
\item
  \textsf{mapParM}, \textsf{mapParM\_}, \textsf{forParM}, and \textsf{forParM\_}
  are the optionally-parallel versions
  of \textsf{mapM}, \textsf{mapM\_}, \textsf{forM}, and \textsf{forM\_}, respectively.
\end{itemize}

\section{Convenience functions}

\begin{itemize}
\item
  \textsf{cnotWire $\var{w}$ $\var{b}$}:
  Equivalent to \textsf{control $\var{b}$ \$ applyX $\var{w}$}.
\item
  \textsf{cnotWires $\var{ws}$ $\var{bs}$}:
  The same as \textsf{mapParM\_ (uncurry cnotWire) \$ zip $\var{ws}$ $\var{bs}$},
  but it produces a more efficient circuit when used inside a \textsf{control} combinator.
\item
  \textsf{swapWire $\var{w}_1$ $\var{w}_2$}:
  A circuit which applies the SWAP gate to two distinct wires~$\var{w}_1$ and~$\var{w}_2$.
  Implemented as \textsf{with\_ (cnotWire $\var{w}_1$ (bit $\var{w}_2$)) \$ cnotWire $\var{w}_2$ (bit $\var{w}_1$)}.
\item
  \textsf{swapWires $\var{ws}_1$ $\var{ws}_2$}:
  The same as \textsf{mapParM\_ (uncurry swapWire) \$ zip $\var{ws}_1$ $\var{ws}_2$},
  but it produces a more efficient circuit when used inside a \textsf{control} combinator.
\item
  \textsf{newWires $\var{n}$} is equivalent to \textsf{replicateParallelQ $\var{n}$ newWire},
  and \textsf{ancillae $\var{n}$} is equivalent to \textsf{replicateParallelQ $\var{n}$ ancilla},
  but they always produce the parallel composition (even if there are control wires).
\item
  \textsf{controls $\var{bs}$ $\var{cir}$}:
  Add all bits in $\var{bs}$ as controls.
  For example, if $\var{bs}$ is \textsf{[$\var{b}_1$, $\var{b}_2$, $\var{b}_3$]},
  then \textsf{controls $\var{bs}$ $\var{cir}$} is equivalent to
  \textsf{control $\var{b}_1$ \$ control $\var{b}_2$ \$ control $\var{b}_3$ $\var{cir}$}.
\item
  \textsf{ifThenElse $\var{b}$ $\var{cir}_1$ $\var{cir}_2$}:
  The sequential composition of
  \textsf{control $\var{b}$ $\var{cir}_1$} and
  \textsf{control (negateBit $\var{b}$) $\var{cir}_2$},
  but it produces a more efficient circuit when used inside a \textsf{control} combinator.
\end{itemize}

\section{Some assumptions made by Hacq}

The types of circuits used in Hacq do not represent
all restrictions required for correct operations.
Although it would be desirable to define the set of assumptions
needed for correct operations of Hacq,
such a set of assumptions is currently not available.
Instead, here are some notable assumptions.

As explained above, combinators \textsf{with} and \textsf{with\_}
expect that any wires allocated by the $\var{prepare}$ part
will be returned to the~$\ket0$ state when they are deallocated.
However, this assumption is not checked,
and nothing prevents a programmer from writing the following code:
\begin{lstlisting}[frame=single,caption={An incorrect use of combinator \textsf{with}.}]
bad :: MonadQuantum w m => m ()
bad =
    with ancilla $ \w ->
      applyH w
      -- #\rmfamily Incorrect: The ancilla is not restored to~$\ket0$.#
\end{lstlisting}

A somewhat related assumption is that the value (of type~\textsf{w})
of an ancillary wire never escapes its scope.
For example, the following code is incorrect
(although the error is not reported):
\begin{lstlisting}[frame=single,caption={Another incorrect use of combinator \textsf{with}.}]
bad :: MonadQuantum w m => m w
bad =
    with ancilla $ \w ->
      return w
      -- #\rmfamily Incorrect: The ancillary wire escapes its scope.#
\end{lstlisting}

\section{Design decisions and future possibilities}

Hacq was originally designed for the TORQUE project in the IARPA QCS Program.
Part of the requirements in the IARPA QCS Program
was to produce an estimate of the amount of resource
to implement certain quantum algorithms in a fault-tolerant manner,
and Hacq was used to produce the number of gates and the width of the logical quantum circuits,
which were further processed to produce the estimates at the fault-tolerant level.
This has a few implications on the design of Hacq:
\begin{itemize}
\item
  Because some of the tasks in the IARPA QCS Program required huge quantum circuits,
  Hacq provides a way to report the resource requirement
  without generating all the gates in the circuit one by one.
\item
  Because the circuits to describe often contained a large amount
  of classical computation which must be performed coherently,
  Hacq takes care of the ancilla management.
\end{itemize}

Hacq is developed as a library in Haskell.
Another option considered was to develop it as a language in its own,
but the expressiveness of Haskell turned out to be very useful
in describing complex circuits.

The monadic style is chosen for convenience to describe circuits.
However, this limits the possibility of static analysis of described circuits.
If we try to make the library choose the most efficient circuit from several choices
in the future,
static analysis will be needed, and the monadic style may become problematic.
Switching from monadic combinators to arrow-style combinators~\cite{SwiDup96AFP,Hughes00SCP}
to allow static analysis of circuits is an option to investigate.

\section*{About license of Hacq}

Copyright \textcopyright\ 2013 NEC Laboratories America, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
\begin{itemize}
\item
  Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
\item
  Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following
  disclaimer in the documentation and/or other materials provided
  with the distribution.
\item
  Neither the name of NEC Laboratories America, Inc.\ nor the names
  of its contributors may be used to endorse or promote products
  derived from this software without specific prior written
  permission.
\end{itemize}

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES\@, INCLUDING\@, BUT NOT
LIMITED TO\@, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED\@.  IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT\@, INDIRECT\@, INCIDENTAL\@,
SPECIAL\@, EXEMPLARY\@, OR CONSEQUENTIAL DAMAGES (INCLUDING\@, BUT NOT
LIMITED TO\@, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES\@; LOSS OF USE\@,
DATA\@, OR PROFITS\@; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY\@, WHETHER IN CONTRACT\@, STRICT LIABILITY\@, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE\@, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

\section*{Acknowledgments}

The author thanks Austin Fowler, Alex Parent, and Martin Roetteler for helpful discussions.
The development of Hacq was supported in part by the Quantum Computer Science Program
of the Intelligence Advanced Research Projects Activity.

\bibliography{hacq}

\end{document}
